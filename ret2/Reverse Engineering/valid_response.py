import interact


def imul(a, b):
    """
    This method emulates the imul instruction.
    returns the upper/lower half
    """
    a &= 0xFFFFFFFF
    b &= 0xFFFFFFFF

    product = a * b
    product &= 0xFFFFFFFFFFFFFFFF

    upper = (product >> 32) & 0xFFFFFFFF # EDX
    lower = product & 0xFFFFFFFF # EAX

    return upper, lower

def remove_characters(string):
    """
    Repeated call decided to create a method for it, removes characters from the provided string.
    """
    removed_chars = []

    for _ in range(6):
        removed_char = string[0]
        removed_chars.append(str(removed_char))
        string = string[1:]

    return removed_chars

def section_1(string):
    """
    Provided the challenge string, this produces the first portion of the response
    """
    removed_chars = remove_characters(string[-20:])
    x58 = 0x00000000 # Intial x58 value

    for index, char in enumerate(removed_chars):

        if index > 0:
            x58 = x58 << 5 # Shifts the x58 value to the left after the first loop

        x58 = x58 ^ ord(char) # Reverses the XOR instruction by XORing the current x58 value with the removed CHAR L > R

    return int(x58)

def section_2(string):
    """
    Provided the challenge string, this produces the second portion of the response
    """
    remove_chars_27 = remove_characters(string[-27:])
    remove_chars_34 = remove_characters(string[-34:])
    remove_chars_13 = remove_characters(string[-13:])
    remove_chars_20 = remove_characters(string[-20:])

    # XOR vars for later
    xor1 = 0 
    xor2 = 0
    xor3 = 0
    xor4 = 0

    xor_list = []
    returned_xor_list = []

    a = 0 # Defining a var for addition later

    for i in range(6):
        
        if i < len(remove_chars_34) and i < len(remove_chars_27) and i < len(remove_chars_13):
            
            char1 = remove_chars_34[i]
            char2 = remove_chars_27[i]
            char3 = remove_chars_13[i]
            
            xor1 = ord(char1) ^ 0x0
            xor2 = xor1 ^ ord(char2)
            xor3 = xor2 ^ ord(char3)

            acsii_char = chr(xor3)

            xor_list.append(acsii_char)

    for index, char in enumerate(xor_list[:6], start=0): # Could be cleaner

        if index < len(remove_chars_20):
            
            char_i = ord(char)
            a = char_i + 0x1 
            xor_c = remove_chars_20[index]
            xor4 = ord(xor_c) ^ a 
            returned_xor_list.append("%02X" % xor4)

        else:
            print("?")
            break

    return ''.join(returned_xor_list)

def section_3(string):

    """
    Provided the challenge string, this produces the third portion of the response
    """

    remove_chars_6 = remove_characters(string[-6:])
    last_section = [] # List containing the last section of the response 
    initial_ecx = 0

    for index, char in enumerate(remove_chars_6[:6], start=0):
        if index == 0:
            initial_ecx = 0xD8
        if index == 1:
            initial_ecx  = 0x32 
        if index == 2:
            initial_ecx = 0x5c 
        if index == 3:
            initial_ecx = 0xef 
        if index == 4:
            initial_ecx = 0x5 
        if index == 5:
            initial_ecx = 0x9a 
        multi_1 = imul(ord(char), initial_ecx)[1] # First IMUL instruction
        upper, lower = imul(multi_1, 0x4ec4ec4f) # Second IMUL instruction calculates EDX and EAX
        sar_edx = upper >> 3 # Shifts the current edx calculation right by 3
        sar_eax = multi_1 >> 31 # Shifts the current eax calculation right by 31
        sub_edx_eax = sar_edx - sar_eax 
        multi_3 = imul(sub_edx_eax, 0x1a)[1] # Third IMUL instruction
        sub_edx_eax2 = multi_1 - multi_3
        eax_add = sub_edx_eax2 + 0x41
        ascii_char = chr(eax_add)
        last_section.append(ascii_char)
    
    return ''.join(last_section)

def challenge(string):
    """
    combines all three sections
    """

    full_response = f"{section_1(string)}:{section_2(string)}:{section_3(string)}"
    
    return full_response

p = interact.Process()
counter = 0
while counter <= 200:
    try:
        print(f"Loop {counter+1}")

        p.readuntil('CHALLENGE: ')
        challenge_bytes = p.readuntil('\n') 
        challenge_string = challenge_bytes.decode('utf-8').strip() 
        print(f"[+] CHALLENGE received: {challenge_string}")
        p.readuntil('RESPONSE: ')
        response = challenge(challenge_string)
        p.sendline(response)
        print(f"Generated RESPONSE: {response}")
        p.flush()

        counter+=1
    except Exception as e:
            print(f"Error: {e}")
